#include "common.hpp"

#include <cstring>
#include <libcdvd.h>
#include <unistd.h>

#include "configexploit.hpp"

// OpenConfig params:
//   0 = must be 00 or 01; becomes bit 1 of config_open_status
//   1 = written to config_open_status+1
//   2 = written to config_open_status+3, and times 16 to config_write_size
// config_open_status+1 selects:
//   0 = config_write_buffer1, offset 0x270
//   1 = config_write_buffer2, offset 0x2B0
//   2 = config_write_buffer3, offset 0x200
//
// ReadConfig:
//   no params
//   reads 16 bytes at config_write_address + value of config_open_status+2
//   subtracts 1 from config_open_status+3
//   adds 16 then mods by 256 to config_open_status+2

enum ConfigBlockID : uint8_t
{
    CONFIG_BLOCK_270 = 0x00,
    CONFIG_BLOCK_2B0 = 0x01,
    CONFIG_BLOCK_200 = 0x02,
};

struct ConfigBlockEntry
{
    ConfigBlockID m_blockID;
    unsigned m_eepromByteAddress;
    size_t m_size;
    size_t m_configInfoOffset;
};
const ConfigBlockEntry s_configBlocks[] =
    {
        {CONFIG_BLOCK_270, 0x270, sizeof(ConfigInfo::m_config270), offsetof(ConfigInfo, m_config270)},
        {CONFIG_BLOCK_2B0, 0x2B0, sizeof(ConfigInfo::m_config2B0), offsetof(ConfigInfo, m_config2B0)},
        {CONFIG_BLOCK_200, 0x200, sizeof(ConfigInfo::m_config200), offsetof(ConfigInfo, m_config200)},
};

// Read EEPROM at a given arbitrary offset.
// The offset is given in bytes, though note that the EEPROM device is
// natively addressed in 16-bit words.
bool ReadNVM(uint8_t *output, unsigned offset, unsigned length)
{
    uint8_t result[3];

    if (offset >= 0x400)
        return false;
    if (0x400 - offset < length)
        return false;

    // ReadNVM takes a big-endian EEPROM offset and returns a big-endian uint16,
    // unlike everything else in PS2 and Mechacon.

    // If offset is odd, even it out.
    if (offset % 2)
    {
        uint8_t wordOffset[2] =
            {
                static_cast<uint8_t>((offset / 2) >> 8),
                static_cast<uint8_t>(offset / 2)};
        if (!sceCdApplySCmd(0x0A, wordOffset, sizeof(wordOffset), result, sizeof(result)))
            return false;
        if (result[0] != 0x00)
            return false;

        *output++ = result[1];
        ++offset;
        --length;
    }

    // Read words.
    while (length >= 2)
    {
        uint8_t wordOffset[2] =
            {
                static_cast<uint8_t>((offset / 2) >> 8),
                static_cast<uint8_t>(offset / 2)};
        if (!sceCdApplySCmd(0x0A, wordOffset, sizeof(wordOffset), result, sizeof(result)))
            return false;
        if (result[0] != 0x00)
            return false;

        *output++ = result[2];
        *output++ = result[1];
        offset += 2;
        length -= 2;
    }

    // If there's one byte remaining, handle it.
    if (length > 0)
    {
        uint8_t wordOffset[2] =
            {
                static_cast<uint8_t>((offset / 2) >> 8),
                static_cast<uint8_t>(offset / 2)};
        if (!sceCdApplySCmd(0x0A, wordOffset, sizeof(wordOffset), result, sizeof(result)))
            return false;
        if (result[0] != 0x00)
            return false;

        *output++ = result[2];
        ++offset;
        --length;
    }

    return true;
}

// Calls OpenConfig with the specified parameters.
bool OpenConfig(bool forWriting, uint8_t whichBlock, uint8_t rowCount)
{
    uint8_t request[3] =
        {
            static_cast<uint8_t>(forWriting),
            whichBlock,
            rowCount};
    uint8_t reply[1];

    if (!sceCdApplySCmd(0x40, request, sizeof(request), reply, sizeof(reply)))
        return false;

    return reply[0] == 0x00;
}

// Reads rowCount * 16 bytes to output.
bool ReadConfig(uint8_t *output, uint8_t rowCount)
{
    for (unsigned row = 0; row < rowCount; ++row)
    {
        uint8_t reply[0x10];
        if (!sceCdApplySCmd(0x41, nullptr, 0, reply, sizeof(reply)))
            return false;

        std::memcpy(&output[row * 0x10], reply, 0x10);
    }

    return true;
}

// Do the WriteConfig command to write to EEPROM.
bool WriteConfig(const uint8_t *data, uint8_t rowCount)
{
    for (unsigned row = 0; row < rowCount; ++row)
    {
        uint8_t reply[1];
        if (!sceCdApplySCmd(0x42, &data[row * 0x10], 0x10, reply, sizeof(reply)))
            return false;

        if (reply[0] != 0x00)
            return false;
    }

    return true;
}

uint8_t CloseConfigInternal()
{
    uint8_t reply[1];
    if (!sceCdApplySCmd(0x43, nullptr, 0, reply, sizeof(reply)))
        return false;

    return reply[0];
}

bool CloseConfigAndWait()
{
    for (;;)
    {
        uint8_t result = CloseConfigInternal();
        if (result == 0x00) // success
            return true;
        else if (result == 0x01) // EEPROM operations not finished
            continue;
        else // some error (config never opened?)
            return false;
    }
}

// Is this 16-byte row valid for WriteConfig?
bool IsValidConfigRowChecksum(const uint8_t *row)
{
    unsigned sum = 0;
    for (int i = 0; i < 15; ++i)
        sum += row[i];
    return row[15] == static_cast<uint8_t>(sum);
}

// Fixes the checksum byte after the 15 data bytes of the row.
void FixConfigRowChecksum(uint8_t *row)
{
    unsigned sum = 0;
    for (int i = 0; i < 15; ++i)
        sum += row[i];
    row[15] = static_cast<uint8_t>(sum);
}

bool ConfigInfo::HasValidChecksums() const
{
    const unsigned char *infoBytes = reinterpret_cast<const unsigned char *>(this);

    for (const ConfigBlockEntry &block : s_configBlocks)
    {
        for (unsigned x = 0; x < block.m_size; x += 0x10)
        {
            if (!IsValidConfigRowChecksum(infoBytes + x))
                return false;
        }
    }

    return true;
}

// Read the standard config blocks (EEPROM 0x200-0x31F).
bool ReadAllConfig(ConfigInfo &info)
{
    unsigned char *infoBytes = reinterpret_cast<unsigned char *>(&info);

    for (const ConfigBlockEntry &block : s_configBlocks)
    {
        if (!OpenConfig(false, block.m_blockID, block.m_size / 0x10))
            return false;
        if (!ReadConfig(infoBytes + block.m_configInfoOffset, block.m_size / 0x10))
            return false;
        if (!CloseConfigAndWait())
            return false;
    }

    return true;
}

// Write the standard config blocks (EEPROM 0x200-0x31F).
bool WriteAllConfig(const ConfigInfo &info)
{
    const unsigned char *infoBytes = reinterpret_cast<const unsigned char *>(&info);

    for (const ConfigBlockEntry &block : s_configBlocks)
    {
        if (!OpenConfig(true, block.m_blockID, block.m_size / 0x10))
            return false;
        if (!WriteConfig(infoBytes + block.m_configInfoOffset, block.m_size / 0x10))
            return false;
        if (!CloseConfigAndWait())
            return false;
    }

    return true;
}

bool WriteConfigExploit(const uint8_t *patchData, int &errorCode)
{
    errorCode = 0;

    // Dump the existing config blocks for restoration.
    ConfigInfo configBackup;
    if (!ReadAllConfig(configBackup))
    {
        errorCode = 1;
        return false;
    }

    // Weird stuff will happen if any rows' checksums are bad.
    if (!configBackup.HasValidChecksums())
    {
        errorCode = 2;
        return false;
    }

    // Both the WriteConfig SCMD handler and the underlying code to write to
    // EEPROM wrap around the buffer after 0x100 bytes because they store the
    // index as uint8.  But we can still ask it to write up to 0x1F0, which
    // it will do.  This will trash config memory, but we just saved it!
    //
    // Do the exploit by wrapping the 0x270 buffer around.
    // Using the 0x270 buffer means that there is 0x70+0x40+0x70 = 0x120
    // bytes of memory to hit our target without corrupting critical
    // structures that happen to be right after the third buffer.  We only
    // need 0x100...
    //
    // The simplest way to do this write is to just imagine that we're
    // writing 0x400 - 0x270 = 0x190 bytes.  The wrapping buffer just means
    // that copies of the patch data end up where config used to be.
    if (!OpenConfig(true, CONFIG_BLOCK_270, 0x190 / 0x10))
    {
        errorCode = 3;
        return false;
    }

    // Write zero rows until it's time to send patch data.
    uint8_t zeros[0x10]{};
    for (int i = 0; i < 0x190 - 0xE0; i += 0x10)
    {
        if (!WriteConfig(zeros, 1))
        {
            // Attempt to restore config.
            CloseConfigAndWait();
            WriteAllConfig(configBackup);

            errorCode = 4;
            return false;
        }
    }

    // Write the 0xE0 bytes of patch data.  However, hold off on the last
    // row for a safety check.
    if (!WriteConfig(patchData, 0xD0 / 0x10))
    {
        // Attempt to restore config.
        CloseConfigAndWait();
        WriteAllConfig(configBackup);

        errorCode = 5;
        return false;
    }

    // Write the final row.
    if (!WriteConfig(patchData + 0xD0, 0x10 / 0x10))
    {
        // Attempt to restore config.
        CloseConfigAndWait();
        WriteAllConfig(configBackup);

        errorCode = 6;
        return false;
    }

    // Need to make sure write finishes...

    sleep(2);

    CloseConfigAndWait();

    // The write succeeded.  Return true no matter what now, but set
    // error code if restoring config fails.
    if (!WriteAllConfig(configBackup))
    {
        errorCode = 7;
        return true;
    }

    uint8_t checkPatchset[0xE0];
    if (!ReadNVM(checkPatchset, 0x320, 0xE0))
    {
        errorCode = 8;
        return false;
    }

    if (std::memcmp(checkPatchset, patchData, 0xE0) != 0)
    {
        errorCode = 9;
        return false;
    }

    return true;
}
